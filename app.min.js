function array_intersection(a, b)
{
  var ai=0, bi=0;
  var result = new Array();

  while( ai < a.length && bi < b.length )
  {
     if      (a[ai] < b[bi] ){ ai++; }
     else if (a[ai] > b[bi] ){ bi++; }
     else /* they're equal */
     {
       result.push(a[ai]);
       ai++;
       bi++;
     }
  }

  return result;
}
var flatten = function(toFlatten) {
  var isArray = Object.prototype.toString.call(toFlatten) === '[object Array]';

  if (isArray && toFlatten.length > 0) {
    var head = toFlatten[0];
    var tail = toFlatten.slice(1);

    return flatten(head).concat(flatten(tail));
  } else {
    return [].concat(toFlatten);
  }
};
Array.prototype.clone = function(){
  return Array.apply(null,this)
};
Array.prototype.sortIt    = Array.prototype.sort;
Array.prototype.reverseIt = Array.prototype.reverse;
Array.prototype.sort = function(){
  var tmp = this.clone();
  return tmp.sortIt.apply(tmp,arguments)
}
Array.prototype.reverse = function(){
  var tmp = this.clone();
  return tmp.reverseIt.apply(tmp,arguments)
}


/* **********************************************
     Begin app.js
********************************************** */

var app = angular.module('searchApp', ['ui.router','angular-md5','ngAnimate']);




app.config(function($stateProvider, $urlRouterProvider) {
  
  $urlRouterProvider.otherwise("/search/water/ROOT");

  $stateProvider
    .state('search', {
      url: "/search/:query",
      controller: 'SearchCtrl',
      templateUrl: 'partials/main.html',
      resolve: {
        InitializeContexts: function (ContextService) {
          return ContextService.promise;
        },
        SearchResults: function (SearchService, $stateParams) {
          return SearchService.search($stateParams.query);
        }
      }
    })
    .state('search.details', {
      url: "/details",
      controller: 'DetailsCtrl',
      templateUrl: 'partials/details.html'
    })
    .state('search.results', {
      url: "/:base64url",
      controller: 'ResultsCtrl',
      templateUrl: 'partials/results.html',
      resolve: {
        url: function ($stateParams, Base64) {
          if ($stateParams.base64url === 'ROOT') return 'ROOT';
          return Base64.decode($stateParams.base64url);
        }
      }
    });

});


app.controller('SearchCtrl', function ($scope, ContextService, $stateParams, $state, $window, Base64) {
  $scope.form = {};
  $scope.form.searchQuery = $stateParams.query;
  $scope.search = function (query) {
    $state.go('search.results',{'query': query,'base64url': 'ROOT'});
  };
  $scope.query = $stateParams.query;
  $scope.goback = false;
  $scope.browse = function (to, from) {
    $window.scrollTo(0,0);
    if (to === 'details') {
      $scope.goback = true;
      $state.go('search.details');
      return;
    } else if (from === '') {
      $scope.goback = false;
    } else if (from === 'details') {
      $scope.goback = false;
    } else {
      var toDepth = ContextService
        .trace(to)
        .length;
      var fromDepth = ContextService
        .trace(from)
        .length;
      $scope.goback = fromDepth > toDepth;
    }
    var encoded = Base64.encode(to);
    $state.go('search.results',{'base64url':encoded});
  };

});

app.controller('DetailsCtrl', function (SearchService, $scope) {
  $scope.count = SearchService.contextCount;
  $scope.tree = [SearchService.contextTree('ROOT')];
});

app.controller('ResultsCtrl', function (ContextService, SearchService, $scope, url) {

  // get the current context
  var context = ContextService.get(url);
  $scope.context = context;

  // get the children
  var directChildContexts = ContextService.children(url).map(function (cntxt) {
    return cntxt.id;
  });

  // and the trace
  $scope.trace = ContextService.trace(url).map(function (node) {
    return ContextService.get(node);
  });

  // start collecting results and dividing them over pages
  var results = SearchService.contextResults(url);

  var activeContexts = [];
  var resultsPerContext = {};

  if (results.length == 0) {
    $scope.noResults = true;
  } else {
    $scope.noResults = false;
  }

  var nResultsPerPage = 12;
  var lastPage = Math.ceil(results.length / nResultsPerPage);
  $scope.lastPage = lastPage;
  $scope.currentPage = 1;
  $scope.pageRange = [];
  for (var i = 1; i <= lastPage; i++) {
    $scope.pageRange.push(i);
  }

  $scope.goToPage = function (pagenr) {
    console.log('go to page', pagenr);
    pagenr = parseInt(pagenr);
    $scope.currentPage = pagenr;
    resultsPerContext = {'GENERAL': []};
    var selection = results.slice((pagenr-1)*nResultsPerPage,pagenr*nResultsPerPage);
    selection.forEach(function (result) {
      var myContexts = flatten(result.contexts.map(function (cntxt) {
        return ContextService.trace(cntxt);
      }));
      var intersection = array_intersection(myContexts.sort(), directChildContexts.sort());
      if (intersection.length > 0) {
        // intersection contains direct children of the current context
        // see if there are active ones
        var alreadyActive = array_intersection(intersection, activeContexts.sort());

        if (alreadyActive.length > 0) {
          // ok, take that one
          if (typeof resultsPerContext[alreadyActive[0]] === 'undefined') {
            resultsPerContext[alreadyActive[0]] = [];
          }
          resultsPerContext[alreadyActive[0]].push(result);
        } else {
          activeContexts.push(intersection[0]);
          resultsPerContext[intersection[0]] = [result];
        }

      } else {
        resultsPerContext['GENERAL'].push(result);
      }
    });
    $scope.resultsPerContext = resultsPerContext;
  }

  $scope.goToPage(1);
  $scope.goBack = function () {
    $scope.goToPage(Math.max($scope.currentPage-1,1));
  };
  $scope.goNext = function () {
    $scope.goToPage(Math.min($scope.currentPage+1,lastPage));
  };

  $scope.contextInfo = ContextService.get;
  $scope.count = SearchService.contextCount;
  $scope.activeContexts = activeContexts;

});


/* **********************************************
     Begin SearchService.js
********************************************** */

angular.module('searchApp')
  .factory('SearchService', function($http, Result, ContextService, $filter) {

    var results = [];

    var resultsPerContext = {};
    var directResultsPerContext = {};

    /**
     * This fills the resultsPerContext & directResultsPerContext objects
     */
    function populateContextResults () {
      resultsPerContext = {};
      directResultsPerContext = {};
      results.forEach(function (res) {
        res.contexts.forEach(function (url) {
          // add to the direct results
          if (typeof directResultsPerContext[url] !== 'undefined') {
            directResultsPerContext[url].push(res);
          } else {
            directResultsPerContext[url] = [res];
          }

          // add the whole t
          var trace = ContextService.trace(url);
          trace.forEach(function (node) {          
            if (typeof resultsPerContext[node] !== 'undefined') {
              resultsPerContext[node].push(res);
            } else {
              resultsPerContext[node] = [res];
            }
          });
        });
      });
      for (var key in resultsPerContext) {
        if (resultsPerContext.hasOwnProperty(key)) {
          resultsPerContext[key] = $filter('unique')(resultsPerContext[key],'id');
        }
      }
    }

    return {

      /**
       * Search: populate results variable and return it as a promise
       * @param  {string} query
       * @return {promise[array]}
       */
      search: function (string) {
        var query = {
          'query': {
            'multi_match': {
              'query': string,
              'fields': [
                "skos:prefLabel^3",
                "skos:definition",
                "title^3",
                "content",
                "concerns_readable^2",
                "context_readable^2"
              ]
            }
          }
        };
        return $http
          .post('http://127.0.0.1:9200/hzbwnature/_search?size=200',query)
          .then(function (res) {
            results = res.data.hits.hits.map(Result.build);
            populateContextResults();
            return results;
          });
      },

      contextTree: function (url) {
        var _this = this;
        var context = ContextService.get(url);
        if (this.contextCount(url) > 8) {
          var children = [];
          ContextService.children(url).forEach(function (child) {
            if (_this.contextCount(child.id) > 0) {
              children.push(child);
            } else {
            }
          });
          context.children = children.map(function (child) {
            return _this.contextTree(child.id);
          });
        } else {
          context.children = [];
        }
        return context;
      },

      directContextCount: function (url) {        
        if (typeof directResultsPerContext[url] === 'undefined') {
          return 0;
        } else {
          return directResultsPerContext[url].length;
        }
      },

      contextCount: function (url) {        
        if (typeof resultsPerContext[url] === 'undefined') {
          return 0;
        } else {
          return resultsPerContext[url].length;
        }
      },

      contextResults: function (url) {        
        if (typeof resultsPerContext[url] === 'undefined') {
          return [];
        } else {
          return resultsPerContext[url];
        }
      }


    };
  });

/* **********************************************
     Begin Context.js
********************************************** */

angular.module('searchApp')
  .factory('Context', function($http, Base64) {

    /**
     * Constructor
     * @param {string} url
     * @param {string} name
     * @param {string} vn
     * @param {string} supercontext
     */
    function Context(url, name, vn, supercontext) {
      this.id = url;
      this.url = url;
      this.encurl = Base64.encode(url);
      this.name = name;
      this.vn = vn || url;
      this.supercontext = supercontext || 'ROOT';
      this.superid = this.supercontext;
    }

    /**
     * Static method: is the context the root context
     * @return {Boolean}
     */
    Context.prototype.isRoot = function () {
      return this.url === 'ROOT';
    };

    /**
     * Create a context instance from ElasticSearch data  
     * @param  {object} data
     * @return {Context}
     */
    Context.build = function (data) {

      var vns = data['_source']['vn_pages'],
          vn = undefined;

      if (vns.length > 0) {
        vn = vns[0];
      }

      return new Context(
        data['_source']['url'],
        data['_source']['name'],
        vn,
        data['_source']['supercontext']
      )
    };

    Context.prototype.link = function () {
      if (typeof this.vn === 'undefined') {
        return this.url;
      } else {
        return this.vn
      }
    };

    Context.root = function () {
      return new Context('ROOT', 'DeltaExpertise', null, null);
    }

    return Context;

  });

/* **********************************************
     Begin Base64.js
********************************************** */

angular.module('searchApp')
  .factory('Base64', function() {
    var keyStr = 'ABCDEFGHIJKLMNOP' +
      'QRSTUVWXYZabcdef' +
      'ghijklmnopqrstuv' +
      'wxyz0123456789+/' +
      '=';
    return {
      encode: function (input) {
        var output = "";
        var chr1, chr2, chr3 = "";
        var enc1, enc2, enc3, enc4 = "";
        var i = 0;

        do {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);

          enc1 = chr1 >> 2;
          enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
          enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
          enc4 = chr3 & 63;

          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }

          output = output +
            keyStr.charAt(enc1) +
            keyStr.charAt(enc2) +
            keyStr.charAt(enc3) +
            keyStr.charAt(enc4);
          chr1 = chr2 = chr3 = "";
          enc1 = enc2 = enc3 = enc4 = "";
        } while (i < input.length);

        return output;
      },

      decode: function (input) {
        var output = "";
        var chr1, chr2, chr3 = "";
        var enc1, enc2, enc3, enc4 = "";
        var i = 0;

        // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
        var base64test = /[^A-Za-z0-9\+\/\=]/g;
        if (base64test.exec(input)) {
          alert("There were invalid base64 characters in the input text.\n" +
            "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" +
            "Expect errors in decoding.");
        }
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

        do {
          enc1 = keyStr.indexOf(input.charAt(i++));
          enc2 = keyStr.indexOf(input.charAt(i++));
          enc3 = keyStr.indexOf(input.charAt(i++));
          enc4 = keyStr.indexOf(input.charAt(i++));

          chr1 = (enc1 << 2) | (enc2 >> 4);
          chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
          chr3 = ((enc3 & 3) << 6) | enc4;

          output = output + String.fromCharCode(chr1);

          if (enc3 != 64) {
            output = output + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output = output + String.fromCharCode(chr3);
          }

          chr1 = chr2 = chr3 = "";
          enc1 = enc2 = enc3 = enc4 = "";

        } while (i < input.length);

        return output;
      }
    };
  });


/* **********************************************
     Begin unique.js
********************************************** */

angular.module('searchApp')
  .filter('unique', function() {
     return function(collection, keyname) {
        var output = [], 
            keys = [];

        angular.forEach(collection, function(item) {
            var key = item[keyname];
            if(keys.indexOf(key) === -1) {
                keys.push(key);
                output.push(item);
            }
        });

        return output;
     };
  });

/* **********************************************
     Begin Result.js
********************************************** */

angular.module('searchApp')
  .factory('Result', function($http,md5) {

    /**
     * Constructor
     */
    function Result(url, title, contexts, type, score,vn) {
      this.id = url;
      this.url = url;
      this.title = title;
      this.vn = vn;
      if (angular.isArray(contexts)) {
        this.contexts = contexts;
      } else {
        this.contexts = [];
      }
      this.type = type;
      this.score = score;
    }

    Result.prototype.link = function () {
      if (typeof this.vn === 'undefined') {
        return this.url;
      } else {
        return this.vn
      }
    };

    /**
     * Create a Result instance from ElasticSearch data  
     * @param  {object} data
     * @return {Result}
     */
    Result.build = function (data) {

      var vns = data['_source']['suggest']['payload']['vn_pages'],
          vn = undefined;

      if (vns.length > 0) {
        vn = vns[0];
      }

      return new Result(
        data['_source']['url'],
        data['_source']['title'],
        data['_source']['context'],
        data['_type'],
        data['_score'],
        vn
      );
    };

    return Result;

  });

/* **********************************************
     Begin ContextService.js
********************************************** */

angular.module('searchApp')
  .factory('ContextService', function($http, Context) {

    var data = {};
    var children = {};

    /**
     * Initialize the data. We create a promise that is added to the service
     * and should be resolved before we can continue.
     */
    var query = {'query': {'match_all': {}}};
    var promise = $http
      .post('http://127.0.0.1:9200/hzbwnature/context/_search?size=1000', query)
      .success(function (res) {
        var contexts = res.hits.hits.map(Context.build)

        // dictionary url > Context
        data = contexts.reduce(function (o, v, i) {
            o[v.id] = v;
            return o;
          }, {});
        data['ROOT'] = Context.root();

        // dictionary url > array[Context]
        children = contexts.reduce(function (o, v, i) {
          if (typeof o[v.supercontext] === 'undefined') {
            o[v.supercontext] = [v];
          } else {
            o[v.supercontext].push(v);
          }
          return o;
        }, {});
      });

    // Actual return object
    return {

      /**
       * This promise should be resolved in the search initialization,
       * and makes sure all information is available
       * @type {promise}
       */
      promise: promise,

      /**
       * Get all contexts
       * @return {dictionary hash > Context}
       */
      all: function () {
        return data;
      },

      /**
       * Get one context by URL
       * @param  {string} hash
       * @return {Context}
       */
      get: function (hash) {
        return data[hash];
      },

      /**
       * Get the children of a certain context
       * @param  {string} url
       * @return {array[Context]}
       */
      children: function (hash) {
        if (typeof children[hash] === 'undefined') {
          return [];
        } else {
          return children[hash];
        }
      },

      /**
       * Trace 
       * @param  {[type]} url
       * @param  {[type]} list
       * @return {[type]}
       */
      trace: function (hash, list) {
        list = typeof list !== 'undefined' ? list : [];
        list.unshift(hash);
        if (hash === 'ROOT') {
          return list
        } else {
          var me = this.get(hash);
          if (typeof me === 'undefined') {
            return list;
          }
          var parent = me.superid;
          return this.trace(parent, list);
        }
      }
    };
  });